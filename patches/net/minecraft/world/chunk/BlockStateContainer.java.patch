--- a/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/net/minecraft/world/chunk/BlockStateContainer.java
@@ -17,6 +17,21 @@
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
 
+/**
+ * Thread-safe version of BlockStateContainer.
+ * The main problems with the Vanilla implementation are that:
+ * <ul>
+ *     <li>{@link BitArray} does not support atomic reads because the data might be spread over multiple longs.
+ *     Also, long isn't guaranteed to be atomic in Java.
+ *     This causes a reader to observe non meaningful values if there is a concurrent writer modifying the same position.</li>
+ *     <li>{@link #onResize(int, Object)} replaces the storage and the palette with new instances and only afterwards copies over the data.
+ *     Moreover, the palette gets shuffled, so a reader might lookup ids using the wrong mappings.
+ *     This causes concurrent readers to observe non meaningful values for all positions.</li>
+ * </ul>
+ *
+ * Operations have {@link ocd.concurrent.MemoryOrder#ACQ_REL} semantics, where "location" in the definition of access modes and memory orderings correspond to values at a fixed position.
+ * {@link ocd.concurrent.ShareMode#SHARED}, {@link ocd.concurrent.ShareMode#EXCLUSIVE_WRITE} and {@link ocd.concurrent.ShareMode#EXCLUSIVE_READ_WRITE} access modes are provided.
+ */
 public class BlockStateContainer<T> implements IBlockStatePaletteResizer<T>
 {
     private final IBlockStatePalette<T> field_205521_b;
@@ -28,11 +43,52 @@
     private final Function<NBTTagCompound, T> deserializer;
     private final Function<T, NBTTagCompound> serializer;
     private final T defaultState;
-    protected BitArray storage;
-    private IBlockStatePalette<T> palette;
     private int bits;
     private final ReentrantLock lock = new ReentrantLock();
+    /**
+     * A shared write lock used by threads writing to this container.
+     * Despite its name, ReadWriteLock has (almost) the exact semantics we need.
+     * "Readers" correspond to writers that can work concurrently.
+     * "Writers" correspond to writers that do structural modifications, ie. which need to change this.data.
+     * The shared write lock makes sure that no structural modifications happen concurrently with other modifications, so that modifications are always written to the right data container.
+     * This lock is also used to guard modifications to the palette, as the palette does not support thread-safe writing.
+     *
+     * Note that ReadWriteLock only guarantees that modifications prior to releasing the write lock are visible to operations subsequent to acquiring a read lock.
+     * However, we also need the other direction, ie. modifications prior to releasing the read lock are visible to operations subsequent to acquiring the write lock.
+     * This ensures that all modifications are visible before the data container is copied over.
+     * ReentrantReadWriteLock doesn't officially provide this guarantee. However, looking at the implementation, it does indeed provide the guarantee through the CAS which has acquire-release semantics.
+     * Ideally, one should write a proper SharedWriteLock, similar to ReentrantReadWriteLock.
+     */
+    private final java.util.concurrent.locks.ReadWriteLock sharedLock = new java.util.concurrent.locks.ReentrantReadWriteLock();
+    /**
+     * The approach described in {@link ocd.concurrent.util.VersionGuard} is used to guard a consistent pair of the storage array and palette.
+     * This is needed because the palette gets reshuffled upon resizing, so we need to make sure that a reader always consults a consistent storage-palette pair.
+     */
+    private final ocd.concurrent.util.VersionGuard versionGuard = new ocd.concurrent.util.VersionGuard();
+    // Both fields are volatile as required by VersionGuard.
+    protected volatile ocd.concurrent.util.AtomicBitArray storage;
+    private volatile IBlockStatePalette<T> palette;
+    /**
+     * New version of the data created during resizing.
+     * We first copy the data to new versions of the storage and palette and afterwards swap the references.
+     * Because we have EXCLUSIVE_READ_WRITE access to those, we can use plain access modes.
+     */
+    protected ocd.concurrent.util.AtomicBitArray tmpStorage;
+    private IBlockStatePalette<T> tmpPalette;
 
+    /**
+     * Swaps the storage-palette pair using {@link ocd.concurrent.util.VersionGuard}.
+     * This is called after the new container is filled.
+     */
+    private void swapData()
+    {
+        // We have exclusive write access.
+        this.versionGuard.startModificationExclusive();
+        this.palette = this.tmpPalette;
+        this.storage = this.tmpStorage;
+        this.versionGuard.endModification();
+    }
+
     private void lock()
     {
         if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread())
@@ -49,11 +105,13 @@
         else
         {
             this.lock.lock();
+            this.sharedLock.writeLock().lock();
         }
     }
 
     private void unlock()
     {
+        this.sharedLock.writeLock().unlock();
         this.lock.unlock();
     }
 
@@ -65,6 +123,7 @@
         this.serializer = p_i48961_4_;
         this.defaultState = p_i48961_5_;
         this.setBits(4);
+        this.swapData(); // Set this.storage and this.palette.
     }
 
     private static int getIndex(int x, int y, int z)
@@ -74,89 +133,409 @@
 
     private void setBits(int bitsIn)
     {
-        if (bitsIn != this.bits)
+        if (true) // We want to use this method even when the bits don't change. Always create a new instance of the storage-palette container because the palette will be shuffled by the caller.
         {
             this.bits = bitsIn;
 
+            // Don't write directly to this.palette and this.storage, the caller will first copy over the relevant data.
             if (this.bits <= 4)
             {
                 this.bits = 4;
-                this.palette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
+                this.tmpPalette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
             }
             else if (this.bits < 9)
             {
-                this.palette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
+                this.tmpPalette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
             }
             else
             {
-                this.palette = this.field_205521_b;
+                this.tmpPalette = this.field_205521_b;
                 this.bits = MathHelper.log2DeBruijn(this.registry.size());
             }
 
-            this.palette.idFor(this.defaultState);
-            this.storage = new BitArray(this.bits, 4096);
+            this.tmpPalette.idFor(this.defaultState);
+            this.tmpStorage = new ocd.concurrent.util.SectionBitArray(this.bits);
         }
     }
 
     public int onResize(int p_onResize_1_, T p_onResize_2_)
     {
         this.lock();
-        BitArray bitarray = this.storage;
+        ocd.concurrent.util.AtomicBitArray bitarray = this.storage;
         IBlockStatePalette<T> iblockstatepalette = this.palette;
         this.setBits(p_onResize_1_);
 
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
         for (int i = 0; i < bitarray.size(); ++i)
         {
-            T t = iblockstatepalette.get(bitarray.getAt(i));
+            T t = iblockstatepalette.get(bitarray.get(i));
 
             if (t != null)
             {
-                this.set(i, t);
+                this.tmpStorage.setPlain(i, this.tmpPalette.idFor(t));
             }
         }
 
-        int j = this.palette.idFor(p_onResize_2_);
+        int j = this.tmpPalette.idFor(p_onResize_2_);
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
         return j;
     }
 
+    /**
+     * Queries the mapping for the specified state.
+     * If none exists yet, a new one is created. This might resize this.palette.
+     *
+     * The caller must not hold a write lock, ie. a lock for this.sharedLock.readLock()/writeLock().
+     *
+     * This method acquires a shared write lock (ie. a lock for this.sharedLock.readLock()) that is transferred to the caller upon returning from this method.
+     * The returned mapping corresponds to the reference of this.palette directly after returning from this method (which is well-defined because the caller then holds a shared write lock, so this.palette doesn't change).
+     */
+    private int idFor(final T state)
+    {
+        // Acquire a shared write lock so that the returned id is consistent with this.palette, ie. the reference to this.palette does not change.
+        this.sharedLock.readLock().lock();
+
+        // Only query an already existing mapping. Don't create a new mapping here, as writing to the palette isn't thread-safe.
+        int id = this.palette.getId(state);
+
+        // The mapping doesn't exist yet.
+        if (id == -1)
+        {
+            // Acquire exclusive access, so we can write to the palette.
+            // This waits until no other thread is writing, in case we need to resize and change the palette, bitArray pair.
+
+            // We need to acquire the exclusive lock here, even if the palette would support thread-safe writing.
+            // This is because we need to acquire the lock inside onResize() and upgrading from a shared lock to an exclusive lock isn't possible.
+            this.sharedLock.readLock().unlock();
+            this.sharedLock.writeLock().lock();
+
+            // We can now write to the palette.
+            id = this.palette.idFor(state);
+
+            // Reacquire the shared lock before releasing the exclusive lock.
+            // This makes sure that id corresponds to this.palette when returning from the method, ie. this.palette does not change inbetween.
+            this.sharedLock.readLock().lock();
+            this.sharedLock.writeLock().unlock();
+        }
+
+        return id;
+    }
+
+    /**
+     * Atomically sets the given state at the specified position and returns the previous state.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.ReadModifyWrite#ACQ_REL}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
+    public T getAndSet(int x, int y, int z, T state)
+    {
+        return this.getAndSet(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified position and returns the previous state.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.ReadModifyWrite#ACQ_REL_EXCLUSIVE}.
+     */
+    public T getAndSetExclusive(int x, int y, int z, T state)
+    {
+        return this.getAndSetExclusive(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified position and returns the previous state.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.ReadModifyWrite#PLAIN}.
+     */
+    public T getAndSetPlain(int x, int y, int z, T state)
+    {
+        return this.getAndSetPlain(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified position and returns the previous state.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    public T getAndSet(int x, int y, int z, T state, int shareMode)
+    {
+        return this.getAndSet(getIndex(x, y, z), state, shareMode);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index and returns the previous state.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.AccessMode.ReadModifyWrite#ACQ_REL}.
+     * This does not require any exclusivity guarantees from the caller.
+     *
+     * The shared lock is used mainly for demonstrational purposes.
+     * In practise, it might be more efficient to use a <code>synchronized</code> version of {@link #getAndSetExclusive(int, Object)} instead.
+     * That is because the payload is quite small, so time sharing shouldn't make much of a difference compared to an exclusive lock.
+     * Furthermore, <code>synchronized</code> is subject to JIT optimizations, in contrast to the shared lock.
+     */
+    protected T getAndSet(int index, T state)
+    {
+        final int id = this.idFor(state);
+        // We now hold a lock for this.sharedLock.readLock().
+        // This makes sure that this.palette and this.data stay consistent during the whole operation.
+
+        // storage.getAndSet() has acquire-release memory consistency guarantees. This gives the desired acquire-release consistency guarantees for the whole operation.
+        // Also, release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        final int prevId = this.storage.getAndSet(index, id);
+
+        // Fetch the palette before releasing the lock. Otherwise it might be changed before we lookup the previous state.
+        final IBlockStatePalette<T> palette  = this.palette;
+        this.sharedLock.readLock().unlock();
+
+        final T t = palette.get(prevId);
+        return t == null ? this.defaultState : t;
+    }
+
+    /**
+     * Atomically sets the given state at the specified index and returns the previous state.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.ReadModifyWrite#ACQ_REL_EXCLUSIVE}.
+     */
+    protected T getAndSetExclusive(int index, T state)
+    {
+        return this.getAndSetExclusive(index, state, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index and returns the previous state.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.ReadModifyWrite#PLAIN}.
+     */
+    protected T getAndSetPlain(int index, T state)
+    {
+        return this.getAndSetExclusive(index, state, ocd.concurrent.ShareMode.EXCLUSIVE_READ_WRITE);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index and returns the previous state.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    protected T getAndSet(int index, T state, int shareMode)
+    {
+        return ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE) ? this.getAndSetExclusive(index, state, shareMode) : this.getAndSet(index, state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index and returns the previous state.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     *
+     * @param shareMode A share mode that {@link ocd.concurrent.ShareMode#allows(int, int) allows} for {@link ocd.concurrent.ShareMode#EXCLUSIVE_WRITE} access
+     */
+    protected T getAndSetExclusive(int index, T state, int shareMode)
+    {
+        // We can elide locks because we are guaranteed exclusive write access.
+        int id = this.palette.idFor(state);
+
+        // storage.getAndSetExclusive() has release memory consistency guarantees. This gives the desired release consistency guarantees for the whole operation.
+        // Also, release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        final int prevId = this.storage.getAndSet(index, id, shareMode);
+
+        final T t = this.palette.get(prevId);
+        return t == null ? this.defaultState : t;
+    }
+
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Write#RELEASE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     public void set(int x, int y, int z, T state)
     {
-        this.lock();
         this.set(getIndex(x, y, z), state);
-        this.unlock();
     }
 
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#RELEASE_EXCLUSIVE}.
+     */
+    public void setExclusive(int x, int y, int z, T state)
+    {
+        this.setExclusive(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#PLAIN}.
+     */
+    public void setPlain(int x, int y, int z, T state)
+    {
+        this.setPlain(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    public void set(int x, int y, int z, T state, int shareMode)
+    {
+        this.set(getIndex(x, y, z), state, shareMode);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.AccessMode.Write#RELEASE}.
+     * This does not require any exclusivity guarantees from the caller.
+     *
+     * The shared lock is used mainly for demonstrational purposes.
+     * In practise, it might be more efficient to use a <code>synchronized</code> version of {@link #setExclusive(int, Object, int)} instead.
+     * That is because the payload is quite small, so time sharing shouldn't make much of a difference compared to an exclusive lock.
+     * Furthermore, <code>synchronized</code> is subject to JIT optimizations, in contrast to the shared lock.
+     */
     protected void set(int index, T state)
     {
-        int i = this.palette.idFor(state);
-        this.storage.setAt(index, i);
+        final int id = this.idFor(state);
+        // We now hold a lock for this.sharedLock.readLock().
+        // This makes sure that this.palette and this.data stay consistent during the whole operation.
+
+        // storage.set() has release memory consistency guarantees. This gives the desired release consistency guarantees for the whole operation.
+        // Also, release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        this.storage.set(index, id);
+        this.sharedLock.readLock().unlock();
     }
 
+    /**
+     * Atomically sets the given state at the specified index.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#RELEASE_EXCLUSIVE}.
+     */
+    protected void setExclusive(int index, T state)
+    {
+        this.setExclusive(index, state, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#PLAIN}.
+     */
+    protected void setPlain(int index, T state)
+    {
+        // Here we could eliminate the use of VersionGuard inside swapData() called through onResize(), as there are no concurrent readers.
+        // However, the performance gain would be negligible and definitely not worth the effort.
+        this.setExclusive(index, state, ocd.concurrent.ShareMode.EXCLUSIVE_READ_WRITE);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    protected void set(int index, T state, int shareMode)
+    {
+        if (ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE))
+            this.setExclusive(index, state, shareMode);
+        else
+            this.set(index, state);
+    }
+
+    /**
+     * Atomically sets the given state at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     *
+     * @param shareMode A share mode that {@link ocd.concurrent.ShareMode#allows(int, int) allows} for {@link ocd.concurrent.ShareMode#EXCLUSIVE_WRITE} access
+     */
+    protected void setExclusive(int index, T state, int shareMode)
+    {
+        // We can elide locks because we are guaranteed exclusive write access.
+        int id = this.palette.idFor(state);
+
+        // storage.setExclusive() has release memory consistency guarantees. This gives the desired release consistency guarantees for the whole operation.
+        // Also, release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        this.storage.set(index, id, shareMode);
+    }
+
+    /**
+     * Atomically gets the state at the specified position.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Read#ACQUIRE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     public T get(int x, int y, int z)
     {
         return (T)this.get(getIndex(x, y, z));
     }
 
+    /**
+     * Atomically gets the state at the specified position.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Read#PLAIN}.
+     */
+    public T getPlain(int x, int y, int z)
+    {
+        return this.getPlain(getIndex(x, y, z));
+    }
+
+    /**
+     * Atomically gets the state at the specified position.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    public T get(int x, int y, int z, int shareMode)
+    {
+        return this.get(getIndex(x, y, z), shareMode);
+    }
+
+    /**
+     * Atomically gets the state at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    protected T get(int index, int shareMode)
+    {
+        return ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE) ? this.getPlain(index) : this.get(index);
+    }
+
+    /**
+     * Atomically gets the state at the specified index.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Read#ACQUIRE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     protected T get(int index)
     {
-        T t = this.palette.get(this.storage.getAt(index));
-        return (T)(t == null ? this.defaultState : t);
+        // We use VersionGuard to fetch a consistent pair of storage and palette.
+        while (true)
+        {
+            final ocd.concurrent.util.VersionGuard.VersionStamp versionStamp = this.versionGuard.getVersion();
+
+            // First fetch all the data, as suggested by VersionGuard.
+
+            final ocd.concurrent.util.AtomicBitArray storage = this.storage;
+            final IBlockStatePalette<T> palette = this.palette;
+
+            // Check for consistency directly after fetching all the data, as suggested by VersionGuard.
+            if (versionStamp.isConsistent())
+            {
+                // We have fetched a consistent storage-palette pair.
+
+                // Both the palette and bitArray read values atomically.
+                // storage.get() has acquire memory consistency guarantees. This gives the desired acquire memory consistency guarantees for the whole operation.
+                // Also, acquire-release semantics make sure that the id is read before the corresponding mapping. This makes sure that a new mapping will be visible.
+                final T t = palette.get(storage.get(index));
+                return t == null ? this.defaultState : t;
+            }
+        }
     }
 
+    /**
+     * Atomically gets the state at the specified index.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Read#PLAIN}.
+     */
+    protected T getPlain(int index)
+    {
+        // We are guaranteed exclusive write access. Hence there are no concurrent writers.
+        // So, we don't need to fetch a consistent version of the data and don't need acquire-release semantics to make sure a new mapping is visible.
+
+        final T t = this.palette.get(this.storage.getPlain(index));
+        return t == null ? this.defaultState : t;
+    }
+
     @OnlyIn(Dist.CLIENT)
     public void read(PacketBuffer buf)
     {
         this.lock();
         int i = buf.readByte();
 
-        if (this.bits != i)
+        if (true) // Always use a new storage-palette pair because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(buf);
-        buf.readLongArray(this.storage.getBackingLongArray());
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
+        this.tmpPalette.read(buf);
+        this.tmpStorage.read(buf);
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
     }
 
@@ -165,7 +544,7 @@
         this.lock();
         buf.writeByte(this.bits);
         this.palette.write(buf);
-        buf.writeLongArray(this.storage.getBackingLongArray());
+        buf.writeLongArray(this.storage.getSerializedLongArray());
         this.unlock();
     }
 
@@ -175,16 +554,17 @@
         NBTTagList nbttaglist = nbt.getList(paletteKey, 10);
         int i = Math.max(4, MathHelper.log2DeBruijn(nbttaglist.size()));
 
-        if (i != this.bits)
+        if (true) // Always use a new storage-palette pair because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(nbttaglist);
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
+        this.tmpPalette.read(nbttaglist);
         long[] along = nbt.getLongArray(blockStatesKey);
         int j = along.length * 64 / 4096;
 
-        if (this.palette == this.field_205521_b)
+        if (this.tmpPalette == this.field_205521_b)
         {
             IBlockStatePalette<T> iblockstatepalette = new BlockStatePaletteHashMap<T>(this.registry, i, this.field_205522_c, this.deserializer, this.serializer);
             iblockstatepalette.read(nbttaglist);
@@ -192,12 +572,12 @@
 
             for (int k = 0; k < 4096; ++k)
             {
-                this.storage.setAt(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
+                this.tmpStorage.setPlain(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
             }
         }
         else if (j == this.bits)
         {
-            System.arraycopy(along, 0, this.storage.getBackingLongArray(), 0, along.length);
+            this.tmpStorage.read(along);
         }
         else
         {
@@ -205,15 +585,17 @@
 
             for (int l = 0; l < 4096; ++l)
             {
-                this.storage.setAt(l, bitarray1.getAt(l));
+                this.tmpStorage.setPlain(l, bitarray1.getAt(l));
             }
         }
 
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
     }
 
     public void writeChunkPalette(NBTTagCompound compound, String paletteName, String paletteDataName)
     {
+        // This does not require locking because we are now thread-safe.
         this.lock();
         BlockStatePaletteHashMap<T> blockstatepalettehashmap = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this.field_205522_c, this.deserializer, this.serializer);
         blockstatepalettehashmap.idFor(this.defaultState);
@@ -241,6 +623,6 @@
 
     public int getSerializedSize()
     {
-        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.getBackingLongArray().length * 8;
+        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.serializedSize() * 8;
     }
 }
