--- a/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/net/minecraft/world/chunk/BlockStateContainer.java
@@ -17,6 +17,25 @@
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
 
+/**
+ * Thread-safe version of BlockStateContainer.
+ * The main problems with the Vanilla implementation are that:
+ * <ul>
+ *     <li>{@link BitArray} does not support atomic reads because the data might be spread over multiple longs.
+ *     Also, long isn't guaranteed to be atomic in Java.
+ *     This causes a reader to observe non meaningful values if there is a concurrent writer modifying the same position.</li>
+ *     <li>{@link #onResize(int, Object)} replaces the storage and the palette with new instances and only afterwards copies over the data.
+ *     Moreover, the palette gets shuffled, so a reader might lookup ids using the wrong mappings.
+ *     This causes concurrent readers to observe non meaningful values for all positions.</li>
+ * </ul>
+ *
+ * Operations have {@link ocd.concurrent.MemoryOrder#ACQ_REL} semantics, where "location" in the definition of access modes and memory orderings correspond to values at a fixed position.
+ * {@link ocd.concurrent.ShareMode#SHARED} and {@link ocd.concurrent.ShareMode#EXCLUSIVE_WRITE} access modes are provided.
+ *
+ * A concurrent reader should not assume ANY memory consistency.
+ * A task that requires any sort of memory consistency should be synchronized by other means. Otherwise chances are high that there are errors even with sequential consistency.
+ * The only guarantee that should be used is atomicity, ie. reads always return meaningful values.
+ */
 public class BlockStateContainer<T> implements IBlockStatePaletteResizer<T>
 {
     private final IBlockStatePalette<T> field_205521_b;
@@ -28,11 +47,55 @@
     private final Function<NBTTagCompound, T> deserializer;
     private final Function<T, NBTTagCompound> serializer;
     private final T defaultState;
-    protected BitArray storage;
-    private IBlockStatePalette<T> palette;
     private int bits;
     private final ReentrantLock lock = new ReentrantLock();
+    /*
+     * A shared write lock used by threads writing to this container.
+     * Despite its name, ReadWriteLock has (almost) the exact semantics we need.
+     * "Readers" correspond to writers that can work concurrently.
+     * "Writers" correspond to writers that do structural modifications, ie. which need to change this.data.
+     * The shared write lock makes sure that no structural modifications happen concurrently with other modifications, so that modifications are always written to the right data container.
+     * This lock is also used to guard modifications to the palette, as the palette does not support thread-safe writing.
+     *
+     * Note that ReadWriteLock only guarantees that modifications prior to releasing the write lock are visible to operations subsequent to acquiring a read lock.
+     * However, we also need the other direction, ie. modifications prior to releasing the read lock are visible to operations subsequent to acquiring the write lock.
+     * This ensures that all modifications are visible before the data container is copied over.
+     * ReentrantReadWriteLock doesn't officially provide this guarantee. However, looking at the implementation, it does indeed provide the guarantee through the CAS which has acquire-release semantics.
+     * Ideally, one should write a proper SharedWriteLock, similar to ReentrantReadWriteLock.
+     */
+    private final java.util.concurrent.locks.ReadWriteLock sharedLock = new java.util.concurrent.locks.ReentrantReadWriteLock();
+    /*
+     * The approach described in VersionUtils is used to guard a consistent pair of the storage array and palette.
+     * This is needed because the palette gets reshuffled upon resizing, so we need to make sure that a reader always consults a consistent storage-palette pair.
+     * Volatile is used to meet the requirements of VersionUtils.
+     * Also, volatile semantics are needed to guarantee volatile semantics for getVolatile() and setVolatile().
+     * Furthermore, acquire-release semantics of volatile make sure that the contents of the storage array and palette are properly initialized when accessing them.
+     */
+    private volatile long version = ocd.concurrent.util.VersionUtils.initVersion();
+    protected volatile ocd.concurrent.util.AtomicBitArray storage;
+    private volatile IBlockStatePalette<T> palette;
+    /*
+     * New version of the data created during resizing.
+     * We first copy the data to new versions of the storage and palette and afterwards swap the references.
+     * Because we have EXCLUSIVE_READ_WRITE access to those, we can use plain access modes.
+     */
+    protected ocd.concurrent.util.AtomicBitArray tmpStorage;
+    private IBlockStatePalette<T> tmpPalette;
 
+    /**
+     * Swaps the storage-palette pair using VersionUtils.
+     * This is called after the new container is filled.
+     */
+    private void swapData()
+    {
+        // We have exclusive write access, so we don't need CAS operations.
+        final long prevVersion = this.version;
+        this.version = ocd.concurrent.util.VersionUtils.startModification(prevVersion);
+        this.palette = this.tmpPalette;
+        this.storage = this.tmpStorage;
+        this.version = ocd.concurrent.util.VersionUtils.endModification(prevVersion);
+    }
+
     private void lock()
     {
         if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread())
@@ -49,11 +112,13 @@
         else
         {
             this.lock.lock();
+            this.sharedLock.writeLock().lock();
         }
     }
 
     private void unlock()
     {
+        this.sharedLock.writeLock().unlock();
         this.lock.unlock();
     }
 
@@ -65,6 +130,7 @@
         this.serializer = p_i48961_4_;
         this.defaultState = p_i48961_5_;
         this.setBits(4);
+        this.swapData(); // Set this.storage and this.palette.
     }
 
     private static int getIndex(int x, int y, int z)
@@ -74,89 +140,246 @@
 
     private void setBits(int bitsIn)
     {
-        if (bitsIn != this.bits)
+        if (true) // We want to use this method even when the bits don't change. Always create a new instance of the storage-palette container because the palette will be shuffled by the caller.
         {
             this.bits = bitsIn;
 
+            // Don't write directly to this.palette and this.storage, the caller will first copy over the relevant data.
             if (this.bits <= 4)
             {
                 this.bits = 4;
-                this.palette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
+                this.tmpPalette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
             }
             else if (this.bits < 9)
             {
-                this.palette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
+                this.tmpPalette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
             }
             else
             {
-                this.palette = this.field_205521_b;
+                this.tmpPalette = this.field_205521_b;
                 this.bits = MathHelper.log2DeBruijn(this.registry.size());
             }
 
-            this.palette.idFor(this.defaultState);
-            this.storage = new BitArray(this.bits, 4096);
+            this.tmpPalette.idFor(this.defaultState);
+            this.tmpStorage = new ocd.concurrent.util.SectionBitArray(this.bits);
         }
     }
 
     public int onResize(int p_onResize_1_, T p_onResize_2_)
     {
         this.lock();
-        BitArray bitarray = this.storage;
+        ocd.concurrent.util.AtomicBitArray bitarray = this.storage;
         IBlockStatePalette<T> iblockstatepalette = this.palette;
         this.setBits(p_onResize_1_);
 
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
         for (int i = 0; i < bitarray.size(); ++i)
         {
-            T t = iblockstatepalette.get(bitarray.getAt(i));
+            T t = iblockstatepalette.get(bitarray.get(i));
 
             if (t != null)
             {
-                this.set(i, t);
+                this.tmpStorage.setExclusive(i, this.tmpPalette.idFor(t));
             }
         }
 
-        int j = this.palette.idFor(p_onResize_2_);
+        int j = this.tmpPalette.idFor(p_onResize_2_);
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
         return j;
     }
 
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Write#RELEASE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     public void set(int x, int y, int z, T state)
     {
-        this.lock();
+        //this.lock();
         this.set(getIndex(x, y, z), state);
-        this.unlock();
+        //this.unlock();
     }
 
+    /**
+     * Atomically sets the given state at the specified position.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#RELEASE_EXCLUSIVE}.
+     */
+    public void setExclusive(int x, int y, int z, T state)
+    {
+        this.setExclusive(getIndex(x, y, z), state);
+    }
+
+    /**
+     * Atomically sets the given value at the specified position.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.AccessMode.Write#RELEASE} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    public void set(int x, int y, int z, T state, int shareMode)
+    {
+        if (ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE))
+            this.setExclusive(x, y, z, state);
+        else
+            this.set(x, y, z, state);
+    }
+
+    /**
+     * Atomically sets the given value at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.AccessMode.Write#RELEASE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     protected void set(int index, T state)
     {
+        // Make sure the storage-palette pair does not get replaced while we write to it.
+        this.sharedLock.readLock().lock();
+        // Only query an already existing mapping. Don't create a new mapping here, as writing to the palette isn't thread-safe.
+        int i = this.palette.getId(state);
+
+        // The mapping doesn't exist yet.
+        if (i == -1)
+        {
+            // Acquire exclusive access, so we can write to the palette.
+            // This waits until no other thread is writing, in case we need to resize and change the container.
+            // We need to acquire the exclusive lock here, even if the palette would support thread-safe writing.
+            // This is because we need to acquire the lock inside onResize() and upgrading from a shared lock to an exclusive lock isn't possible there.
+            // Just releasing the shared lock and not acquiring the exclusive lock is also not possible since in this case this.data might be replaced while we are writing to the palette.
+            this.sharedLock.readLock().unlock();
+            this.sharedLock.writeLock().lock();
+
+            // We can now write to the palette.
+            i = this.palette.idFor(state);
+
+            this.sharedLock.readLock().lock();
+            this.sharedLock.writeLock().unlock();
+        }
+        // storage.set() has release memory consistency guarantees. This gives the desired release consistency guarantees for the whole operation.
+        // Also, acquire-release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        // Re-fetch this.storage because it might have been changed due to resizing inside idFor().
+        this.storage.set(index, i);
+        this.sharedLock.readLock().unlock();
+    }
+
+    /**
+     * Atomically sets the given value at the specified index.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Write#RELEASE_EXCLUSIVE}.
+     */
+    protected void setExclusive(int index, T state)
+    {
+        // We can elide locks because we are guaranteed exclusive write access.
         int i = this.palette.idFor(state);
-        this.storage.setAt(index, i);
+        // Acquire-release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        this.storage.setExclusive(index, i);
     }
 
+    /**
+     * Atomically sets the given value at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    protected void set(int index, T state, int shareMode)
+    {
+        if (ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE))
+            this.setExclusive(index, state);
+        else
+            this.set(index, state);
+    }
+
+    /**
+     * Atomically gets the state at the specified position.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Read#ACQUIRE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     public T get(int x, int y, int z)
     {
         return (T)this.get(getIndex(x, y, z));
     }
 
+    /**
+     * Atomically gets the value at the specified position.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Read#PLAIN}.
+     */
+    public T getPlain(int x, int y, int z)
+    {
+        return this.getPlain(getIndex(x, y, z));
+    }
+
+    /**
+     * Atomically gets the value at the specified position.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    public T get(int x, int y, int z, int shareMode)
+    {
+        return ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE) ? this.getPlain(x, y, z) : this.get(x, y, z);
+    }
+
+    /**
+     * Atomically gets the state at the specified index.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.AccessMode.Read#ACQUIRE}.
+     * This does not require any exclusivity guarantees from the caller.
+     */
     protected T get(int index)
     {
-        T t = this.palette.get(this.storage.getAt(index));
-        return (T)(t == null ? this.defaultState : t);
+        // We use VersionUtils to fetch a consistent pair of storage and palette.
+        while (true)
+        {
+            final long version = this.version;
+
+            // Both the palette and bitArray read values atomically.
+            // storage.get() has acquire memory consistency guarantees. This gives the desired acquire memory consistency guarantees for the whole operation.
+            // Also, acquire-release semantics make sure that the id is read before the corresponding mapping. This makes sure that a new mapping will be visible.
+            // Fetching the id on the fly, rather than first fetching the storage-palette pair, turns out to be more efficient, as suggested by VersionUtils.
+            final int id = this.storage.get(index);
+            final IBlockStatePalette<T> palette = this.palette;
+
+            // Check for consistency directly after fetching all the data, as suggested by VersionUtils.
+            if (ocd.concurrent.util.VersionUtils.isConsistent(version, this.version))
+            {
+                // We have fetched a consistent storage-palette pair.
+                final T t = palette.get(id);
+                return t == null ? this.defaultState : t;
+            }
+        }
     }
 
+    /**
+     * Atomically gets the value at the specified index.
+     * This has the memory consistency guarantees and exclusivity requirements as defined by {@link ocd.concurrent.AccessMode.Read#PLAIN}.
+     */
+    protected T getPlain(int index)
+    {
+        // We are guaranteed exclusive write access. Hence there are no concurrent writers.
+        // So, we don't need to fetch a consistent version of the data and don't need acquire-release semantics to make sure a new mapping is visible.
+
+        // Do this operation in two steps.
+        // Writing this.palette.get(this.storage.get(index)) in a single line would force the palette to be loaded before evaluating the id.
+        // Fetching it afterwards turns out to be slightly more efficient.
+        final int id = this.storage.get(index);
+        final T t = this.palette.get(id);
+        return t == null ? this.defaultState : t;
+    }
+
+    /**
+     * Atomically gets the value at the specified index.
+     * This has the memory consistency guarantees defined by {@link ocd.concurrent.MemoryOrder#ACQ_REL} and exclusivity requirements as defined by the specified <code>shareMode</code>.
+     */
+    protected T get(int index, int shareMode)
+    {
+        return ocd.concurrent.ShareMode.allows(shareMode, ocd.concurrent.ShareMode.EXCLUSIVE_WRITE) ? this.getPlain(index) : this.get(index);
+    }
+
     @OnlyIn(Dist.CLIENT)
     public void read(PacketBuffer buf)
     {
         this.lock();
         int i = buf.readByte();
 
-        if (this.bits != i)
+        if (true) // Always use a new storage-palette pair because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(buf);
-        buf.readLongArray(this.storage.getBackingLongArray());
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
+        this.tmpPalette.read(buf);
+        this.tmpStorage.read(buf);
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
     }
 
@@ -165,7 +388,7 @@
         this.lock();
         buf.writeByte(this.bits);
         this.palette.write(buf);
-        buf.writeLongArray(this.storage.getBackingLongArray());
+        buf.writeLongArray(this.storage.getSerializedLongArray());
         this.unlock();
     }
 
@@ -175,16 +398,17 @@
         NBTTagList nbttaglist = nbt.getList(paletteKey, 10);
         int i = Math.max(4, MathHelper.log2DeBruijn(nbttaglist.size()));
 
-        if (i != this.bits)
+        if (true) // Always use a new storage-palette pair because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(nbttaglist);
+        // Write to tmpStorage and tmpPalette and only swap it once the data is filled in.
+        this.tmpPalette.read(nbttaglist);
         long[] along = nbt.getLongArray(blockStatesKey);
         int j = along.length * 64 / 4096;
 
-        if (this.palette == this.field_205521_b)
+        if (this.tmpPalette == this.field_205521_b)
         {
             IBlockStatePalette<T> iblockstatepalette = new BlockStatePaletteHashMap<T>(this.registry, i, this.field_205522_c, this.deserializer, this.serializer);
             iblockstatepalette.read(nbttaglist);
@@ -192,12 +416,12 @@
 
             for (int k = 0; k < 4096; ++k)
             {
-                this.storage.setAt(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
+                this.tmpStorage.setExclusive(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
             }
         }
         else if (j == this.bits)
         {
-            System.arraycopy(along, 0, this.storage.getBackingLongArray(), 0, along.length);
+            this.tmpStorage.read(along);
         }
         else
         {
@@ -205,15 +429,17 @@
 
             for (int l = 0; l < 4096; ++l)
             {
-                this.storage.setAt(l, bitarray1.getAt(l));
+                this.tmpStorage.setExclusive(l, bitarray1.getAt(l));
             }
         }
 
+        this.swapData(); // Swap the storage-palette pair after copying the data.
         this.unlock();
     }
 
     public void writeChunkPalette(NBTTagCompound compound, String paletteName, String paletteDataName)
     {
+        // This does not require locking because we are now thread-safe.
         this.lock();
         BlockStatePaletteHashMap<T> blockstatepalettehashmap = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this.field_205522_c, this.deserializer, this.serializer);
         blockstatepalettehashmap.idFor(this.defaultState);
@@ -241,6 +467,6 @@
 
     public int getSerializedSize()
     {
-        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.getBackingLongArray().length * 8;
+        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.serializedSize() * 8;
     }
 }
