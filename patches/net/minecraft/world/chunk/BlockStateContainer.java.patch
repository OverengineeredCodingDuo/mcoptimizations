--- a/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/net/minecraft/world/chunk/BlockStateContainer.java
@@ -17,6 +17,24 @@
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
 
+/**
+ * Thread-safe version of BlockStateContainer.
+ * The main problems with the Vanilla implementation are that:
+ * <ul>
+ *     <li>{@link BitArray} does not support atomic reads because the data might be spread over multiple longs.
+ *     Also, long isn't guaranteed to be atomic in Java.
+ *     This causes a reader to observe non meaningful values if there is a concurrent writer modifying the same position.</li>
+ *     <li>{@link #onResize(int, Object)} replaces the storage and the palette with new instances and only afterwards copies over the data.
+ *     Moreover, the palette gets shuffled, so a reader might lookup ids using the wrong mappings.
+ *     This causes concurrent readers to observe non meaningful values for all positions.</li>
+ * </ul>
+ *
+ * This implementation has the memory effects of volatile reads and writes respectively.
+ * In particular, all accesses together with all accesses of volatile variables have a coherent ordering among all threads.
+ * However, a concurrent reader should not assume ANY memory consistentcy.
+ * A task that requires any sort of memory consistency should be synchronized by other means. Otherwise chances are high that there are errors even with sequential consistency.
+ * The only guarantee that should be used is atomicity, ie. reads always return meaningful values.
+ */
 public class BlockStateContainer<T> implements IBlockStatePaletteResizer<T>
 {
     private final IBlockStatePalette<T> field_205521_b;
@@ -28,11 +46,62 @@
     private final Function<NBTTagCompound, T> deserializer;
     private final Function<T, NBTTagCompound> serializer;
     private final T defaultState;
-    protected BitArray storage;
-    private IBlockStatePalette<T> palette;
     private int bits;
     private final ReentrantLock lock = new ReentrantLock();
+    /*
+     * A shared write lock used by threads writing to this container.
+     * Despite its name, ReadWriteLock has (almost) the exact semantics we need.
+     * "Readers" correspond to writers that can work concurrently.
+     * "Writers" correspond to writers that do structural modifications, ie. which need to change this.data.
+     * The shared write lock makes sure that no structural modifications happen concurrently with other modifications, so that modifications are always written to the right data container.
+     * This lock is also used to guard modifications to the palette, as the palette does not support thread-safe writing.
+     *
+     * Note that ReadWriteLock only guarantees that modifications prior to releasing the write lock are visible to operations subsequent to acquiring a read lock.
+     * However, we also need the other direction, ie. modifications prior to releasing the read lock are visible to operations subsequent to acquiring the write lock.
+     * This ensures that all modifications are visible before the data container is copied over.
+     * ReentrantReadWriteLock doesn't officially provide this guarantee. However, looking at the implementation, it does indeed provide the guarantee through the CAS which has acquire-release semantics.
+     * Ideally, one should write a proper SharedWriteLock, similar to ReentrantReadWriteLock.
+     */
+    private final java.util.concurrent.locks.ReadWriteLock sharedLock = new java.util.concurrent.locks.ReentrantReadWriteLock();
+    /*
+     * Storage array packed together with a consistent version of the palette.
+     * volatile semantics are needed to guarantee volatile semantics for getAt() and setAt().
+     * Also, the acquire-release semantics of volatile make sure that any modifications to the data are written before the container is swapped.
+     */
+    protected volatile DataContainer<T> data;
+    /*
+     * New version of the data container created during resizing.
+     * It is important that the data is copied before replacing the instance of the container, so that readers will always see the fully-copied data.
+     */
+    protected DataContainer<T> tmpData;
 
+    /**
+     * Container for a consistent pair of storage and palette.
+     * This is needed because the palette gets reshuffled upon resizing, so we need to make sure that a reader always consults a consistent storage-palette pair.
+     */
+    protected static class DataContainer<T>
+    {
+        protected final ocd.concurrent.util.AtomicBitArray storage;
+        private final IBlockStatePalette<T> palette;
+
+        public DataContainer(final ocd.concurrent.util.AtomicBitArray storage, final IBlockStatePalette<T> palette)
+        {
+            this.storage = storage;
+            this.palette = palette;
+        }
+    }
+
+    /**
+     * Atomically swaps the storage-palette container.
+     * This is called after the new container is filled.
+     */
+    private void swapData()
+    {
+        // Acquire-release semantics of volatile make sure that the data is written to the container before swapping the instance.
+        this.data = this.tmpData;
+        this.tmpData = null;
+    }
+
     private void lock()
     {
         if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread())
@@ -49,11 +118,13 @@
         else
         {
             this.lock.lock();
+            this.sharedLock.writeLock().lock();
         }
     }
 
     private void unlock()
     {
+        this.sharedLock.writeLock().unlock();
         this.lock.unlock();
     }
 
@@ -65,6 +136,7 @@
         this.serializer = p_i48961_4_;
         this.defaultState = p_i48961_5_;
         this.setBits(4);
+        this.swapData(); // Set the data container.
     }
 
     private static int getIndex(int x, int y, int z)
@@ -74,36 +146,44 @@
 
     private void setBits(int bitsIn)
     {
-        if (bitsIn != this.bits)
+        if (true) // We want to use this method even when the bits don't change. Always create a new instance of the storage-palette container because the palette will be shuffled by the caller.
         {
+            final IBlockStatePalette<T> palette;
+
             this.bits = bitsIn;
 
             if (this.bits <= 4)
             {
                 this.bits = 4;
-                this.palette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
+                palette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
             }
             else if (this.bits < 9)
             {
-                this.palette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
+                palette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
             }
             else
             {
-                this.palette = this.field_205521_b;
+                palette = this.field_205521_b;
                 this.bits = MathHelper.log2DeBruijn(this.registry.size());
             }
 
-            this.palette.idFor(this.defaultState);
-            this.storage = new BitArray(this.bits, 4096);
+            palette.idFor(this.defaultState);
+            final ocd.concurrent.util.AtomicBitArray storage = new ocd.concurrent.util.AtomicBitArray(this.bits, 4096);
+
+            // Don't write directly to this.data, the caller will first copy over the relevant data.
+            this.tmpData = new DataContainer<>(storage, palette);
         }
     }
 
     public int onResize(int p_onResize_1_, T p_onResize_2_)
     {
         this.lock();
-        BitArray bitarray = this.storage;
-        IBlockStatePalette<T> iblockstatepalette = this.palette;
+        final DataContainer<T> data = this.data;
+        ocd.concurrent.util.AtomicBitArray bitarray = data.storage;
+        IBlockStatePalette<T> iblockstatepalette = data.palette;
         this.setBits(p_onResize_1_);
+        // Write to a temporary container and only swap it once the data is filled in.
+        final DataContainer<T> tmpData = this.tmpData;
 
         for (int i = 0; i < bitarray.size(); ++i)
         {
@@ -111,15 +191,20 @@
 
             if (t != null)
             {
-                this.set(i, t);
+                tmpData.storage.setAt(i, tmpData.palette.idFor(t));
             }
         }
 
-        int j = this.palette.idFor(p_onResize_2_);
+        int j = tmpData.palette.idFor(p_onResize_2_);
+        this.swapData(); // Swap the storage-palette container after copying the data.
         this.unlock();
         return j;
     }
 
+    /**
+     * Sets the given state at the given position atomically.
+     * This has the memory effect of a volatile write.
+     */
     public void set(int x, int y, int z, T state)
     {
         this.lock();
@@ -129,10 +214,40 @@
 
     protected void set(int index, T state)
     {
-        int i = this.palette.idFor(state);
-        this.storage.setAt(index, i);
+        // Make sure the container does not get replaced while we write to it.
+        this.sharedLock.readLock().lock();
+        // Only query an already existing mapping. Don't create a new mapping here, as writing to the palette isn't thread-safe.
+        int i = this.data.palette.getId(state);
+
+        // The mapping doesn't exist yet.
+        if (i == -1)
+        {
+            // Acquire exclusive access, so we can write to the palette.
+            // This waits until no other thread is writing, in case we need to resize and change the container.
+            // We need to acquire the exclusive lock here, even if the palette would support thread-safe writing.
+            // This is because we need to acquire the lock inside onResize() and upgrading from a shared lock to an exclusive lock isn't possible there.
+            // Just releasing the shared lock and not acquiring the exclusive lock is also not possible since in this case this.data might be replaced while we are writing to the palette.
+            this.sharedLock.readLock().unlock();
+            this.sharedLock.writeLock().lock();
+
+            // We can now write to the palette.
+            i = this.data.palette.idFor(state);
+
+            this.sharedLock.readLock().lock();
+            this.sharedLock.writeLock().unlock();
+        }
+        // AtomicBitArray.setAt() and AtomicBitArray.getAt() have the semantics of a volatile write and read respectively.
+        // Together with the volatile semantics of this.data, this gives the claimed volatile semantics for the whole operation.
+        // Also, in case a new mapping is added, the acquire-release semantics of volatile make sure that it is written before the corresponding id is written to the bitArray.
+        // Re-fetch this.data because it might have been changed due to resizing inside idFor().
+        this.data.storage.setAt(index, i);
+        this.sharedLock.readLock().unlock();
     }
 
+    /**
+     * Reads the state at the given position atomically.
+     * This has the memory effect of a volatile read.
+     */
     public T get(int x, int y, int z)
     {
         return (T)this.get(getIndex(x, y, z));
@@ -140,7 +255,13 @@
 
     protected T get(int index)
     {
-        T t = this.palette.get(this.storage.getAt(index));
+        // Use a consistent storage-palette pair for both lookups.
+        final DataContainer<T> data = this.data;
+        // Both the palette and bitArray read values atomically.
+        // AtomicBitArray.setAt() and AtomicBitArray.getAt() have the semantics of a volatile write and read respectively.
+        // Together with the volatile semantics of this.data, this gives the claimed volatile semantics for the whole operation.
+        // Also, the acquire-release semantics of volatile make sure that the id is read before the corresponding mapping. Hence the mapping will exist.
+        T t = data.palette.get(data.storage.getAt(index));
         return (T)(t == null ? this.defaultState : t);
     }
 
@@ -150,22 +271,28 @@
         this.lock();
         int i = buf.readByte();
 
-        if (this.bits != i)
+        if (true) // Always use a new container because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(buf);
-        buf.readLongArray(this.storage.getBackingLongArray());
+        // Write to a temporary container and only swap it once the data is filled in.
+        final DataContainer<T> tmpData = this.tmpData;
+        tmpData.palette.read(buf);
+        tmpData.storage.read(buf);
+        this.swapData(); // Only swap the container after filling in all data.
         this.unlock();
     }
 
     public void write(PacketBuffer buf)
     {
+        // This does not require locking because the data is now thread-safe.
+        // However, without the lock, the bitArray should be serialized before the palette and an acquireFence should be inserted inbetween, in case a new mapping is added concurrently.
         this.lock();
+        final DataContainer<T> data = this.data;
         buf.writeByte(this.bits);
-        this.palette.write(buf);
-        buf.writeLongArray(this.storage.getBackingLongArray());
+        data.palette.write(buf);
+        buf.writeLongArray(data.storage.getSerializedLongArray());
         this.unlock();
     }
 
@@ -175,16 +302,18 @@
         NBTTagList nbttaglist = nbt.getList(paletteKey, 10);
         int i = Math.max(4, MathHelper.log2DeBruijn(nbttaglist.size()));
 
-        if (i != this.bits)
+        if (true) // Always use a new container because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(nbttaglist);
+        // Write to a temporary container and only swap it once the data is filled in.
+        final DataContainer<T> tmpData = this.tmpData;
+        tmpData.palette.read(nbttaglist);
         long[] along = nbt.getLongArray(blockStatesKey);
         int j = along.length * 64 / 4096;
 
-        if (this.palette == this.field_205521_b)
+        if (tmpData.palette == this.field_205521_b)
         {
             IBlockStatePalette<T> iblockstatepalette = new BlockStatePaletteHashMap<T>(this.registry, i, this.field_205522_c, this.deserializer, this.serializer);
             iblockstatepalette.read(nbttaglist);
@@ -192,12 +321,12 @@
 
             for (int k = 0; k < 4096; ++k)
             {
-                this.storage.setAt(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
+                tmpData.storage.setAt(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
             }
         }
         else if (j == this.bits)
         {
-            System.arraycopy(along, 0, this.storage.getBackingLongArray(), 0, along.length);
+            tmpData.storage.read(along);
         }
         else
         {
@@ -205,15 +334,17 @@
 
             for (int l = 0; l < 4096; ++l)
             {
-                this.storage.setAt(l, bitarray1.getAt(l));
+                tmpData.storage.setAt(l, bitarray1.getAt(l));
             }
         }
 
+        this.swapData(); // Only swap the container after filling in all data.
         this.unlock();
     }
 
     public void writeChunkPalette(NBTTagCompound compound, String paletteName, String paletteDataName)
     {
+        // This does not require locking because we are now thread-safe.
         this.lock();
         BlockStatePaletteHashMap<T> blockstatepalettehashmap = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this.field_205522_c, this.deserializer, this.serializer);
         blockstatepalettehashmap.idFor(this.defaultState);
@@ -241,6 +372,7 @@
 
     public int getSerializedSize()
     {
-        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.getBackingLongArray().length * 8;
+        final DataContainer<T> data = this.data;
+        return 1 + data.palette.getSerializedSize() + PacketBuffer.getVarIntSize(data.storage.size()) + data.storage.serializedSize() * 8;
     }
 }
