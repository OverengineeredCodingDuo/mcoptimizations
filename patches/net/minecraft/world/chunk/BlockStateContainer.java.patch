--- a/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/net/minecraft/world/chunk/BlockStateContainer.java
@@ -17,7 +17,25 @@
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
 
-public class BlockStateContainer<T> implements IBlockStatePaletteResizer<T>
+/**
+ * Thread-safe version of BlockStateContainer.
+ * The main problems with the Vanilla implementation are that:
+ * <ul>
+ *     <li>{@link BitArray} does not support atomic reads because the data might be spread over multiple longs.
+ *     Also, long isn't guaranteed to be atomic in Java.
+ *     This causes a reader to observe non meaningful values if there is a concurrent writer modifying the same position.</li>
+ *     <li>{@link #onResize(int, Object)} replaces the storage and the palette with new instances and only afterwards copies over the data.
+ *     Moreover, the palette gets shuffled, so a reader might lookup ids using the wrong mappings.
+ *     This causes concurrent readers to observe non meaningful values for all positions.</li>
+ * </ul>
+ *
+ * Convenience overloads are provided for the access modes defined in {@link ocd.concurrent.AccessMode}.
+ *
+ * A concurrent reader should not assume ANY memory consistency.
+ * A task that requires any sort of memory consistency should be synchronized by other means. Otherwise chances are high that there are errors even with sequential consistency.
+ * The only guarantee that should be used is atomicity, ie. reads always return meaningful values.
+ */
+public class BlockStateContainer<T> implements IBlockStatePaletteResizer<T>, ocd.concurrent.util.AtomicObjectArray<T>
 {
     private final IBlockStatePalette<T> field_205521_b;
     private final IBlockStatePaletteResizer<T> field_205522_c = (p_205517_0_, p_205517_1_) ->
@@ -28,11 +46,68 @@
     private final Function<NBTTagCompound, T> deserializer;
     private final Function<T, NBTTagCompound> serializer;
     private final T defaultState;
-    protected BitArray storage;
-    private IBlockStatePalette<T> palette;
     private int bits;
     private final ReentrantLock lock = new ReentrantLock();
+    /*
+     * A shared write lock used by threads writing to this container.
+     * Despite its name, ReadWriteLock has (almost) the exact semantics we need.
+     * "Readers" correspond to writers that can work concurrently.
+     * "Writers" correspond to writers that do structural modifications, ie. which need to change this.data.
+     * The shared write lock makes sure that no structural modifications happen concurrently with other modifications, so that modifications are always written to the right data container.
+     * This lock is also used to guard modifications to the palette, as the palette does not support thread-safe writing.
+     *
+     * Note that ReadWriteLock only guarantees that modifications prior to releasing the write lock are visible to operations subsequent to acquiring a read lock.
+     * However, we also need the other direction, ie. modifications prior to releasing the read lock are visible to operations subsequent to acquiring the write lock.
+     * This ensures that all modifications are visible before the data container is copied over.
+     * ReentrantReadWriteLock doesn't officially provide this guarantee. However, looking at the implementation, it does indeed provide the guarantee through the CAS which has acquire-release semantics.
+     * Ideally, one should write a proper SharedWriteLock, similar to ReentrantReadWriteLock.
+     */
+    private final java.util.concurrent.locks.ReadWriteLock sharedLock = new java.util.concurrent.locks.ReentrantReadWriteLock();
+    /*
+     * Storage array packed together with a consistent version of the palette.
+     * volatile semantics are needed to guarantee volatile semantics for get() and set().
+     * Also, the acquire-release semantics of volatile make sure that any modifications to the data are written before the container is swapped.
+     */
+    protected volatile ocd.concurrent.util.AtomicBitArray storage;
+    private volatile IBlockStatePalette<T> palette;
+    private volatile int version;
+    /*
+     * New version of the data container created during resizing.
+     * It is important that the data is copied before replacing the instance of the container, so that readers will always see the fully-copied data.
+     * Because we have EXCLUSIVE_READ_WRITE access to tmpData, we can use plain access modes.
+     */
+    protected ocd.concurrent.util.AtomicBitArray tmpStorage;
+    private IBlockStatePalette<T> tmpPalette;
 
+    /**
+     * Container for a consistent pair of storage and palette.
+     * This is needed because the palette gets reshuffled upon resizing, so we need to make sure that a reader always consults a consistent storage-palette pair.
+     */
+    protected static class DataContainer<T>
+    {
+        protected final ocd.concurrent.util.AtomicBitArray storage;
+        private final IBlockStatePalette<T> palette;
+
+        public DataContainer(final ocd.concurrent.util.AtomicBitArray storage, final IBlockStatePalette<T> palette)
+        {
+            this.storage = storage;
+            this.palette = palette;
+        }
+    }
+
+    /**
+     * Atomically swaps the storage-palette container.
+     * This is called after the new container is filled.
+     */
+    private void swapData()
+    {
+        // Acquire-release semantics of volatile make sure that the data is written to the container before swapping the instance.
+        this.version = ocd.concurrent.util.VersionUtils.startModification(this.version);
+        this.storage = this.tmpStorage;
+        this.palette = this.tmpPalette;
+        this.version = ocd.concurrent.util.VersionUtils.endModification(this.version);
+    }
+
     private void lock()
     {
         if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread())
@@ -49,11 +124,13 @@
         else
         {
             this.lock.lock();
+            this.sharedLock.writeLock().lock();
         }
     }
 
     private void unlock()
     {
+        this.sharedLock.writeLock().unlock();
         this.lock.unlock();
     }
 
@@ -64,7 +141,9 @@
         this.deserializer = p_i48961_3_;
         this.serializer = p_i48961_4_;
         this.defaultState = p_i48961_5_;
+        this.storage = new ocd.concurrent.util.AtomicBitArray(4, 4096);
         this.setBits(4);
+        this.swapData(); // Set the data container.
     }
 
     private static int getIndex(int x, int y, int z)
@@ -74,65 +153,168 @@
 
     private void setBits(int bitsIn)
     {
-        if (bitsIn != this.bits)
+        if (true) // We want to use this method even when the bits don't change. Always create a new instance of the storage-palette container because the palette will be shuffled by the caller.
         {
+            final IBlockStatePalette<T> palette;
+
             this.bits = bitsIn;
 
             if (this.bits <= 4)
             {
                 this.bits = 4;
-                this.palette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
+                this.tmpPalette = new BlockStatePaletteLinear<T>(this.registry, this.bits, this, this.deserializer);
             }
             else if (this.bits < 9)
             {
-                this.palette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
+                this.tmpPalette = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this, this.deserializer, this.serializer);
             }
             else
             {
-                this.palette = this.field_205521_b;
+                this.tmpPalette = this.field_205521_b;
                 this.bits = MathHelper.log2DeBruijn(this.registry.size());
             }
 
-            this.palette.idFor(this.defaultState);
-            this.storage = new BitArray(this.bits, 4096);
+            this.tmpPalette.idFor(this.defaultState);
+            this.tmpStorage = new ocd.concurrent.util.AtomicBitArray(this.bits, 4096);
+
+            // Don't write directly to this.data, the caller will first copy over the relevant data.
         }
     }
 
     public int onResize(int p_onResize_1_, T p_onResize_2_)
     {
         this.lock();
-        BitArray bitarray = this.storage;
+        ocd.concurrent.util.AtomicBitArray bitarray = this.storage;
         IBlockStatePalette<T> iblockstatepalette = this.palette;
         this.setBits(p_onResize_1_);
+        // Write to a temporary container and only swap it once the data is filled in.
 
         for (int i = 0; i < bitarray.size(); ++i)
         {
-            T t = iblockstatepalette.get(bitarray.getAt(i));
+            T t = iblockstatepalette.get(bitarray.getPlain(i));
 
             if (t != null)
             {
-                this.set(i, t);
+                this.tmpStorage.setPlain(i, this.tmpPalette.idFor(t));
             }
         }
 
-        int j = this.palette.idFor(p_onResize_2_);
+        int j = this.tmpPalette.idFor(p_onResize_2_);
+        this.swapData(); // Swap the storage-palette container after copying the data.
         this.unlock();
         return j;
     }
 
+    /**
+     * Sets the given state at the given position atomically.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.MemoryOrder#OPAQUE}.
+     */
     public void set(int x, int y, int z, T state)
     {
         this.lock();
-        this.set(getIndex(x, y, z), state);
+        this.setOpaqueExclusive(getIndex(x, y, z), state);
         this.unlock();
     }
 
-    protected void set(int index, T state)
+    @Override
+    public void setOpaque(int index, T state)
     {
+        this.setShared(index, state, ocd.concurrent.MemoryOrder.OPAQUE);
+    }
+
+    @Override
+    public void setRelease(int index, T state)
+    {
+        this.setShared(index, state, ocd.concurrent.MemoryOrder.ACQ_REL);
+    }
+
+    @Override
+    public void setVolatile(int index, T state)
+    {
+        this.setShared(index, state, ocd.concurrent.MemoryOrder.VOLATILE);
+    }
+
+    @Override
+    public void setShared(int index, T state, int memoryOrder)
+    {
+        // We need acquire-release semantics to make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        memoryOrder = ocd.concurrent.MemoryOrder.enforce(memoryOrder, ocd.concurrent.MemoryOrder.ACQ_REL);
+
+        // Make sure the container does not get replaced while we write to it.
+        this.sharedLock.readLock().lock();
+        // Only query an already existing mapping. Don't create a new mapping here, as writing to the palette isn't thread-safe.
+        int i = this.palette.getId(state);
+
+        // The mapping doesn't exist yet.
+        if (i == -1)
+        {
+            // Acquire exclusive access, so we can write to the palette.
+            // This waits until no other thread is writing, in case we need to resize and change the container.
+            // We need to acquire the exclusive lock here, even if the palette would support thread-safe writing.
+            // This is because we need to acquire the lock inside onResize() and upgrading from a shared lock to an exclusive lock isn't possible there.
+            // Just releasing the shared lock and not acquiring the exclusive lock is also not possible since in this case this.data might be replaced while we are writing to the palette.
+            this.sharedLock.readLock().unlock();
+            this.sharedLock.writeLock().lock();
+
+            // We can now write to the palette.
+            i = this.palette.idFor(state);
+
+            this.sharedLock.readLock().lock();
+            this.sharedLock.writeLock().unlock();
+        }
+        // storage.setShared() has the requested memory consistency guarantees.
+        // Together with the volatile semantics of this.data, this gives the desired memory consistency guarantees for the whole operation.
+        // Also, we enforced acquire-release semantics to make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        // Re-fetch this.data because it might have been changed due to resizing inside idFor().
+        this.storage.setShared(index, i, memoryOrder);
+        this.sharedLock.readLock().unlock();
+    }
+
+    @Override
+    public void setExclusive(int index, T state, int memoryOrder)
+    {
+        // Enforce acquire-release semantics as required by setExclusive_().
+        this.setExclusive_(index, state, ocd.concurrent.MemoryOrder.getExclusiveWriteAccessMode(ocd.concurrent.MemoryOrder.enforce(memoryOrder, ocd.concurrent.MemoryOrder.ACQ_REL)));
+    }
+
+    @Override
+    public void setOpaqueExclusive(int index, T state)
+    {
+        this.setExclusive(index, state, ocd.concurrent.MemoryOrder.OPAQUE);
+    }
+
+    @Override
+    public void setReleaseExclusive(int index, T state)
+    {
+        this.setExclusive(index, state, ocd.concurrent.MemoryOrder.ACQ_REL);
+    }
+
+    @Override
+    public void setVolatileExclusive(int index, T state)
+    {
+        this.setExclusive(index, state, ocd.concurrent.MemoryOrder.VOLATILE);
+    }
+
+    @Override
+    public void setPlain(int index, T state)
+    {
+        this.setExclusive_(index, state, ocd.concurrent.AccessMode.Write.PLAIN);
+    }
+
+    // Requires that accessMode implies MemoryOrder.ACQ_REL, unless accessMode is PLAIN.
+    private void setExclusive_(int index, T state, int accessMode)
+    {
+        // We can elide locks because we are guaranteed exclusive write access.
         int i = this.palette.idFor(state);
-        this.storage.setAt(index, i);
+        // Acquire-release semantics make sure that a new mapping is written before the corresponding id is written to the bitArray.
+        // This is not needed for PLAIN accessMode, as there are no concurrent readers and changes are required to be made visible by the outer synchronization mechanism.
+        this.storage.set(index, i, accessMode);
     }
 
+    /**
+     * Reads the state at the given position atomically.
+     * This has the memory consistency guarantees of {@link ocd.concurrent.MemoryOrder#OPAQUE}.
+     */
     public T get(int x, int y, int z)
     {
         return (T)this.get(getIndex(x, y, z));
@@ -140,7 +322,57 @@
 
     protected T get(int index)
     {
-        T t = this.palette.get(this.storage.getAt(index));
+        return this.getOpaque(index);
+    }
+
+    @Override
+    public T getShared(int index, int memoryOrder)
+    {
+        // We need acquire-release semantics to make sure that the id is read before the corresponding mapping.
+
+        // Use a consistent storage-palette pair for both lookups.
+        // Both the palette and bitArray read values atomically.
+        // storage.getShared() has the requested memory consistency guarantees.
+        // Together with the volatile semantics of this.data, this gives the desired memory consistency guarantees for the whole operation.
+        // Also, we enforced acquire-release semantics to make sure that the id is read before the corresponding mapping. This makes sure that a new mapping will be visible.
+        while (true)
+        {
+            final int version = this.version;
+            final int i = this.storage.getShared(index, ocd.concurrent.MemoryOrder.enforce(memoryOrder, ocd.concurrent.MemoryOrder.ACQ_REL));
+            final IBlockStatePalette<T> palette = this.palette;
+
+            if (ocd.concurrent.util.VersionUtils.isConsistent(version, this.version))
+            {
+                final T t = palette.get(i);
+                return t == null ? this.defaultState : t;
+            }
+        }
+    }
+
+    @Override
+    public T getVolatile(int index)
+    {
+        return this.getShared(index, ocd.concurrent.MemoryOrder.VOLATILE);
+    }
+
+    @Override
+    public T getAcquire(int index)
+    {
+        return this.getShared(index, ocd.concurrent.MemoryOrder.ACQ_REL);
+    }
+
+    @Override
+    public T getOpaque(int index)
+    {
+        return this.getShared(index, ocd.concurrent.MemoryOrder.OPAQUE);
+    }
+
+    @Override
+    public T getPlain(int index)
+    {
+        // We are guaranteed exclusive write access. Hence there are no concurrent writers.
+        // So, we don't need to fetch a consistent version of the data container and don't need acquire-release semantics to make sure a new mapping is visible.
+        T t = this.palette.get(this.storage.getPlain(index));
         return (T)(t == null ? this.defaultState : t);
     }
 
@@ -150,13 +382,15 @@
         this.lock();
         int i = buf.readByte();
 
-        if (this.bits != i)
+        if (true) // Always use a new container because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(buf);
-        buf.readLongArray(this.storage.getBackingLongArray());
+        // Write to a temporary container and only swap it once the data is filled in.
+        this.tmpPalette.read(buf);
+        this.tmpStorage.read(buf);
+        this.swapData(); // Only swap the container after filling in all data.
         this.unlock();
     }
 
@@ -165,7 +399,7 @@
         this.lock();
         buf.writeByte(this.bits);
         this.palette.write(buf);
-        buf.writeLongArray(this.storage.getBackingLongArray());
+        buf.writeLongArray(this.storage.getSerializedLongArray());
         this.unlock();
     }
 
@@ -175,16 +409,17 @@
         NBTTagList nbttaglist = nbt.getList(paletteKey, 10);
         int i = Math.max(4, MathHelper.log2DeBruijn(nbttaglist.size()));
 
-        if (i != this.bits)
+        if (true) // Always use a new container because the palette might be shuffled.
         {
             this.setBits(i);
         }
 
-        this.palette.read(nbttaglist);
+        // Write to a temporary container and only swap it once the data is filled in.
+        this.tmpPalette.read(nbttaglist);
         long[] along = nbt.getLongArray(blockStatesKey);
         int j = along.length * 64 / 4096;
 
-        if (this.palette == this.field_205521_b)
+        if (this.tmpPalette == this.field_205521_b)
         {
             IBlockStatePalette<T> iblockstatepalette = new BlockStatePaletteHashMap<T>(this.registry, i, this.field_205522_c, this.deserializer, this.serializer);
             iblockstatepalette.read(nbttaglist);
@@ -192,12 +427,12 @@
 
             for (int k = 0; k < 4096; ++k)
             {
-                this.storage.setAt(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
+                this.tmpStorage.setPlain(k, this.field_205521_b.idFor(iblockstatepalette.get(bitarray.getAt(k))));
             }
         }
         else if (j == this.bits)
         {
-            System.arraycopy(along, 0, this.storage.getBackingLongArray(), 0, along.length);
+            this.tmpStorage.read(along);
         }
         else
         {
@@ -205,15 +440,17 @@
 
             for (int l = 0; l < 4096; ++l)
             {
-                this.storage.setAt(l, bitarray1.getAt(l));
+                this.tmpStorage.setPlain(l, bitarray1.getAt(l));
             }
         }
 
+        this.swapData(); // Only swap the container after filling in all data.
         this.unlock();
     }
 
     public void writeChunkPalette(NBTTagCompound compound, String paletteName, String paletteDataName)
     {
+        // This does not require locking because we are now thread-safe.
         this.lock();
         BlockStatePaletteHashMap<T> blockstatepalettehashmap = new BlockStatePaletteHashMap<T>(this.registry, this.bits, this.field_205522_c, this.deserializer, this.serializer);
         blockstatepalettehashmap.idFor(this.defaultState);
@@ -221,7 +458,7 @@
 
         for (int i = 0; i < 4096; ++i)
         {
-            aint[i] = blockstatepalettehashmap.idFor((T)this.get(i));
+            aint[i] = blockstatepalettehashmap.idFor((T)this.getOpaque(i));
         }
 
         NBTTagList nbttaglist = new NBTTagList();
@@ -241,6 +478,6 @@
 
     public int getSerializedSize()
     {
-        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.getBackingLongArray().length * 8;
+        return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.serializedSize() * 8;
     }
 }
